#include "Player.h"
#include "MathUtillity.h"
#include "Keys.h"
#include <cassert>
#include <cmath>
#include <imgui.h>

#include "Stage.h"
#include "LevelData.h"

#include "PilotManager.h"
#include "TransitionManager.h"

using YGame::Transform;
using YMath::Vector2;
using YMath::Vector3;
using YMath::Clamp;

YInput::Keys* Player::spKeys_ = nullptr;

void Player::StaticInitialize()
{
	// キーインスタンス取得
	spKeys_ = YInput::Keys::GetInstance();
}

void Player::Initialize(const size_t signIndex, const YMath::Vector3& pos, const bool isExistKey)
{
	// トランスフォーム生成
	transform_.reset(new Transform());

	// 描画クラス初期化
	drawer_.Initialize(transform_.get(), &direction_);

	// リセット
	Reset(signIndex, pos, isExistKey);
}

void Player::Reset(const size_t signIndex, const YMath::Vector3& pos, const bool isExistKey)
{
	// トランスフォーム初期化
	transform_->Initialize({ pos + spStageMan_->GetTopLeftPos(signIndex), {}, {1.0f,1.0f,1.0f} });

	// 前回左上位置初期化
	elderLeftTop_ = spStageMan_->GetTopLeftPos(signIndex);

	// スピード初期化
	speed_ = {};
	
	// 向き (右)
	direction_ = Vector3(+1, 0, 0);

	// ジャンプカウントリセット
	jumpCount_ = 0;


	// コライダー位置初期化
	Box2D::SetBox2DCenter({ transform_->pos_.x_, transform_->pos_.y_ });

	// コライダーサイズ初期化
	Box2D::SetBox2DRadSize({ LevelData::Player::CollRadSize });

	// コライダータイプ設定
	ObjectCollider::SetColliderType(ObjectCollider::Type::ePlayer);

	// コライダー看板番号設定
	ObjectCollider::SetSignIndex(signIndex);


	// マップチップコライダー初期化
	YukiMapchipCollider::Initialize();
	trfm_ = *transform_;
	radius_ = { LevelData::Player::CollRadSize.x_, LevelData::Player::CollRadSize.y_, 0.0f };
	idxSign_ = signIndex;
	YukiMapchipCollider::UpdatePos();
	

	// 生きている
	isAlive_ = true;

	// 落下フラグをうごかすか
	isGetOffAct_ = false;

	// 落下フラグタイマー
	isGetOffTimer_.Initialize(5);
	isGetOffTimer_.SetActive(false);


	// 鍵を持っているか
	isKeyHolder_ = !isExistKey;

	// クリアか
	isGameClear_ = false;


	// 描画クラスリセット
	drawer_.Reset();

	drawer_.AnimateRespawn();
}

void Player::Move()
{
	if (PilotManager::StaticGetIsActInit()) { return; }

	// ゴールした後は無視
	if (isGameClear_) { return; }

	// x軸移動
	speed_.x_ += spKeys_->Horizontal() * LevelData::Player::Acceleration;

	// 保存用フラグ
	bool isMove = false;

	// 移動しているなら
	if (spKeys_->Horizontal() != 0)
	{
		// フラグをtrueに
		isMove = true;

		// 向き変更
		if (speed_.x_ > 0) { direction_.x_ = +1.0f; }
		if (speed_.x_ < 0) { direction_.x_ = -1.0f; }
	}

	// 移動アニメーション
	drawer_.SetActMoveAnimation(isMove);
}

void Player::Jump()
{
	if (PilotManager::StaticGetIsActInit()) { return; }

	// ゴールした後は無視
	if (isGameClear_) { return; }

	// ジャンプ回数が最大なら弾く
	if (1 <= jumpCount_) { return; }

	// 特殊アクション中なら弾く
	if (spKeys_->IsDown(DIK_E)) { return; }

	// SPACEキー押したら
	if (spKeys_->IsTrigger(DIK_SPACE) || spKeys_->IsTrigger(DIK_W))
	{
		// ジャンプ
		speed_.y_ = LevelData::Player::JumpPower;

		// ジャンプアニメーション
		drawer_.AnimateJump();

		// ジャンプカウント
		jumpCount_++;
	}
}

void Player::Landing()
{
	// 重力をなくす
	speed_.y_ = 0.0f;

	// ジャンプカウントリセット
	jumpCount_ = 0;

	// 着地した瞬間なら
	if (IsLandingMoment() || (isGrounded_ && isOldGrounded_ == false) && 
		spStageMan_->isHoldSignVector_[idxSign_] == false)
	{
		// 着地アニメーション
		drawer_.AnimateLanding();
	}
}

void Player::UpdatePhysics()
{
	if (PilotManager::StaticGetCurrentPilot() != PilotManager::PilotType::ePlayer) { return; }
	
	// 持ってたら弾く
	if (spStageMan_->isHoldSignVector_[idxSign_]) { return; }

	// 移動
	Move();

	// ジャンプ
	Jump();

	// 摩擦力
	if (speed_.x_ > 0.0f)
	{
		speed_.x_ -= LevelData::Player::Friction;
		speed_.x_ = (std::max)(0.0f, speed_.x_);
	}
	if (speed_.x_ < 0.0f)
	{
		speed_.x_ += LevelData::Player::Friction;
		speed_.x_ = (std::min)(0.0f, speed_.x_);
	}

	// 重力
	speed_.y_ -= LevelData::Player::Gravity;

	// クランプ
	speed_.x_ = Clamp(speed_.x_, -LevelData::Player::MaxSpeed.x_, +LevelData::Player::MaxSpeed.x_);
	speed_.y_ = Clamp(speed_.y_, -LevelData::Player::MaxGravity, +LevelData::Player::MaxSpeed.y_);
}

Vector3& Player::PosRef()
{
	return transform_->pos_;
}

Vector3& Player::SpeedRef()
{
	return speed_;
}

Vector3* Player::PosPointer()
{
	return &transform_->pos_;
}

void Player::OnCollision(ObjectCollider* pPair)
{
	// ゲームクリア時弾く
	if (isGameClear_) { return; }

	// 持ってたら弾く
	if (spStageMan_->isHoldSignVector_[idxSign_]) { return; }

	// ブロックなら
	if (pPair->GetColliderType() == ObjectCollider::Type::eBlock)
	{
		// E でアクション
		pPair->SetIsActSkill(spKeys_->IsDown(DIK_E));
	}
	// レーザーなら
	else if (pPair->GetColliderType() == ObjectCollider::Type::eLaser)
	{
		if (isAlive_ == false) { return; }

		// 死ぬ
		isAlive_ = false;
		
		// アニメーション
		drawer_.AnimateDead();
	}
	// スイッチなら
	else if (pPair->GetColliderType() == ObjectCollider::Type::eSwitch)
	{
		// E でアクション
		if (spKeys_->IsTrigger(DIK_E))
		{
			pPair->SetIsActSkill(true);
		}
	}
	// 鍵なら
	else if (pPair->GetColliderType() == ObjectCollider::Type::eKey)
	{
		// 鍵を所持する
		isKeyHolder_ = true;
	}
	// ゴールなら
	else if (pPair->GetColliderType() == ObjectCollider::Type::eGoal)
	{
		// 鍵持ってないなら
		if (isKeyHolder_ == false) { return; }

		pPair->SetIsActSkill(true);

		// ゴール
		drawer_.AnimateGoal();

		// ゲームクリア
		isGameClear_ = true;
	}
}

void Player::Draw()
{
	// 描画
	drawer_.Draw();
}

void Player::DrawDebug(void)
{
    //ImGui::Begin("p");
    //ImGui::Text("trfm:%f,%f,%f", trfm_.pos_.x_, trfm_.pos_.y_, trfm_.pos_.z_);
    //ImGui::Text("speed:%f,%f,%f", speed_.x_, speed_.y_, speed_.z_);
    //ImGui::End();
}

void Player::Update()
{
	// 代入
	trfm_.pos_ = transform_->pos_;
	velocity_ = speed_;
	
	// 判定
	spStageMan_->CallPPC(this);
	if (isTeleport_)
	{
		isTeleport_ = false;
		isGrounded_ = false;
		trfm_.pos_ = { roundToDecimal(teleportedPos_.x_, decimalPlace_),roundToDecimal(teleportedPos_.y_,  decimalPlace_),roundToDecimal(teleportedPos_.z_,  decimalPlace_) };
		idxSign_ = teleportedIdxSign_;

		// 看板インデックス更新
		SetSignIndex(idxSign_);
		elderLeftTop_ = spStageMan_->GetTopLeftPos(GetSignIndex());

		// テレポートアニメーション
		drawer_.AnimateTeleport();

		PilotManager::StaticSetFollowStage(idxSign_);
	}
	
	// 戻す
	transform_->pos_ = trfm_.pos_;
	speed_ = velocity_;
}

void Player::PreUpdate()
{
	// 座標更新
	YukiMapchipCollider::UpdatePos();
    DrawDebug();
	
	// 看板インデックス更新
	SetSignIndex(idxSign_);

	// 左上更新
	UpdateLeftTop();

	// 物理挙動更新
	UpdatePhysics();
	

	// 下入力 から タイマー終了まで降りる
	if (spKeys_->IsUnder())
	{
		isGetOffAct_ = true;
		isGetOffTimer_.Reset(true);
	}
	isGetOffTimer_.Update();
	if (isGetOffTimer_.IsEnd())
	{
		isGetOffAct_ = false;
	}

	// 降りるか
	SetIsGetOff(isGetOffAct_);

	// 持ってたら弾く
	if (spStageMan_->isHoldSignVector_[idxSign_] == false)
	{
		// 着地フラグ初期化
		ResetIsLanding();
	}

	// マップチップコライダー更新
	Update();
	
	
	// コライダー位置更新
	Box2D::SetBox2DCenter({ transform_->pos_.x_, transform_->pos_.y_ });
}

void Player::PostUpdate()
{
	// 着地時
	if (IsLanding() || isGrounded_)
	{
		// 着地
 		Landing();
	}

	// 持ってたら弾く
	if (spStageMan_->isHoldSignVector_[idxSign_] == false && 
		PilotManager::StaticGetCurrentPilot() == PilotManager::PilotType::ePlayer)
	{
		// 移動
		transform_->pos_ += speed_;
	}

	// トランスフォーム行列更新
	transform_->UpdateMatrix();

	// 描画クラス更新
	drawer_.Update();
}

